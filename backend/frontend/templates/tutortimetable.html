<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>Tutor Timetable</title>
    <link href="https://cdn.jsdelivr.net/npm/bootstrap@5.3.3/dist/css/bootstrap.min.css" rel="stylesheet" />
    <style>
        .grid {
            width: 100%;
            border-collapse: collapse;
            table-layout: fixed
        }

        .grid th,
        .grid td {
            border: 1px solid #e5e7eb;
            text-align: center;
            padding: 8px
        }

        .grid thead th {
            background: #f1f5f9
        }

        .timecol {
            width: 80px;
            background: #f8fafc;
            font-weight: 600
        }

        .slot {
            height: 60px;
            vertical-align: top;
            position: relative
        }

        .event {
            position: absolute;
            left: 6px;
            right: 6px;
            border-radius: 4px;
            padding: 4px 6px;
            background: #86efac
        }

        .title {
            font-weight: 600
        }
    </style>

    <script src="https://cdn.jsdelivr.net/npm/html2canvas@1.4.1/dist/html2canvas.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/jspdf@2.5.1/dist/jspdf.umd.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/xlsx@0.18.5/dist/xlsx.full.min.js"></script>
</head>

<body>
    <div class="container py-4">
        <h1 class="h5 m-0 mb-3">Timetable</h1>

        <div id="ttCapture">
            <div class="d-flex justify-content-between align-items-center mb-2 gap-2 flex-wrap">
                <div id="exportHeader">
                    <div class="fw-semibold">
                        Tutor: <span id="exName"></span> (<span id="exEmail"></span>)
                    </div>
                    <div class="text-muted small">
                        Semester: <span id="exAlias"></span> | Updated on: <span id="exWhen"></span>
                    </div>
                </div>

                <div class="d-flex align-items-center gap-2">
                    <div class="btn-group">
                        <button class="btn btn-outline-primary btn-sm" id="btnDownloadPdf">Download PDF</button>
                        <button class="btn btn-outline-primary btn-sm" id="btnDownloadPng">Download PNG</button>
                        <button class="btn btn-outline-primary btn-sm" id="btnDownloadXlsx">Download XLSX</button>

                        <button class="btn btn-primary btn-sm dropdown-toggle" href="#" id="btnShareviaEmail">
                            Share via email
                        </button>
                    </div>
                    <a id="backLink" href="/home/" class="btn btn-outline-secondary btn-sm">‚Üê Back</a>
                </div>
            </div>

            <div id="gridWrap" class="table-responsive"></div>
        </div>

        <div id="empty" class="alert alert-warning d-none mt-3">No assigned classes for this tutor.</div>
    </div>

    <script>
        const API_BASE = "/api";
        const token = () => localStorage.getItem("access");
        const authHeaders = (extra = {}) => token() ? ({ ...extra, Authorization: `Bearer ${token()}` }) : extra;

        const qs = new URLSearchParams(location.search);
        const aliasParam = qs.get("alias") || "";
        let tutorName = qs.get("name") || "";
        let tutorEmail = (qs.get("email") || "").toLowerCase();

        const backLink = document.getElementById("backLink");

        // preserve allocations back link if present
        if (document.referrer && document.referrer.includes('/allocations/')) {
            backLink.href = document.referrer;
        } else {
            backLink.href = '/home/';
        }

        async function apiGet(path) {
            const res = await fetch(`${API_BASE}${path}`, { headers: authHeaders(), credentials: "include" });
            let data = null; try { data = await res.json(); } catch { }
            if (res.status === 401) { location.href = "/"; throw new Error("Unauthorized"); }
            if (!res.ok) { throw new Error(data?.detail || `GET ${path} -> ${res.status}`); }
            return data || [];
        }

        async function getProfile() { return apiGet('/accounts/profile/'); }

        async function getCurrentAlias() {
            try {
                const res = await fetch(`${API_BASE}/semesters/current/`, { headers: authHeaders(), credentials: "include" });
                if (!res.ok) throw new Error();
                const { alias } = await res.json();
                return alias || "";
            } catch { return ""; }
        }

        // Keep a copy of the filtered sessions for exporting to XLSX
        let _mineRows = [];

        document.addEventListener("DOMContentLoaded", async () => {
            if (!token()) { location.href = "/"; return; }

            // Establish identity/role and lock for Tutors
            let me = null, roles = [];
            try {
                me = await getProfile();
                roles = Array.isArray(me?.roles) ? me.roles.map(r => r.name) : [];
            } catch { }

            const isAdmin = !!me?.is_staff || roles.includes('Admin');
            const isCoord = roles.includes('Coordinator');
            const isTutor = roles.includes('Tutor') && !isAdmin && !isCoord;

            if (isTutor) {
                tutorEmail = (me?.user?.email || me?.email || '').toLowerCase();
                tutorName = `${me?.user?.first_name || me?.first_name || ''} ${me?.user?.last_name || me?.last_name || ''}`.trim()
                    || (me?.user?.username || me?.username || '');
            }

            // reflect in URL (without reload)
            const url = new URL(location.href);
            const alias = aliasParam || await getCurrentAlias();
            if (alias) url.searchParams.set('alias', alias);
            if (tutorName) url.searchParams.set('name', tutorName);
            if (tutorEmail) url.searchParams.set('email', tutorEmail);
            history.replaceState(null, '', url);

            // Fetch sessions for this alias and filter by this tutor
            let useAlias = aliasParam || await getCurrentAlias();
            try {
                const all = await apiGet(`/timetable/sessions/?alias=${encodeURIComponent(useAlias)}`);
                const mine = all.filter(s => {
                    if (tutorEmail) return ((s.tutor_email || '').toLowerCase() === tutorEmail);
                    if (tutorName) return ((s.tutor || '').toLowerCase() === (tutorName || '').toLowerCase());
                    return false;
                });

                _mineRows = mine; // store for export
                if (!mine.length) {
                    document.getElementById("empty").classList.remove("d-none");
                    return;
                }
                renderWeekGrid(mine);
            } catch (e) {
                alert(e.message || e);
            }

            document.getElementById("exName").textContent = tutorName || "";
            document.getElementById("exEmail").textContent = tutorEmail || "";
            document.getElementById("exAlias").textContent = useAlias || (alias || "");
            document.getElementById("exWhen").textContent = new Date().toLocaleString();

            // Hook up export & share
            document.getElementById("btnDownloadPdf").addEventListener("click", async () => {
                const { blob, filename } = await captureAsPdf();
                triggerDownload(blob, filename);
            });
            document.getElementById("btnDownloadPng").addEventListener("click", async () => {
                const { blob, filename } = await captureAsPng();
                triggerDownload(blob, filename);
            });
            document.getElementById("btnDownloadXlsx").addEventListener("click", () => {
                const { blob, filename } = buildXlsx();
                triggerDownload(blob, filename);
            });

            document.getElementById("btnShareviaEmail").addEventListener("click", async (e) => {
                e.preventDefault();
                const { blob, filename } = await captureAsPdf();
                shareViaEmail({ blob, filename, mime: "application/pdf" });
            });
        });

        const DAYS = ["Monday", "Tuesday", "Wednesday", "Thursday", "Friday"];
        const HSTART = 8, HEND = 20;

        function renderWeekGrid(rows) {
            const byDay = new Map(DAYS.map(d => [d, []]));
            rows.forEach(r => byDay.get(r.day_of_week || "")?.push(r));

            let html = `<table id="ttTable" class="grid"><thead><tr><th class="timecol">Time</th>`;
            DAYS.forEach(d => html += `<th>${d}</th>`);
            html += `</tr></thead><tbody>`;

            for (let h = HSTART; h <= HEND; h++) {
                html += `<tr><th class="timecol">${h}:00</th>`;
                for (const day of DAYS) {
                    const matches = (byDay.get(day) || []).filter(s => {
                        const parts = (s.start_time || "").split(":").map(n => parseInt(n, 10));
                        const hour = Number.isFinite(parts[0]) ? parts[0] : -1;
                        return hour === h; // place on starting hour only
                    });
                    html += `<td class="slot">`;
                    matches.forEach(s => {
                        const code = (s.activity_code || "").toUpperCase();
                        const label = `${code}${s.location ? ` ${s.location}` : ""}${s.weeks ? ` ${s.weeks}` : ""}`;
                        html += `<div class="event" title="${label}">${code}${s.location ? `<br/>${s.location}` : ""}${s.weeks ? `<br/>${s.weeks}` : ""}</div>`;
                    });
                    html += `</td>`;
                }
                html += `</tr>`;
            }

            html += `</tbody></table>`;
            document.getElementById("gridWrap").innerHTML = html;
        }

        // ---------- Export helpers ----------
        function triggerDownload(blob, filename) {
            const a = document.createElement('a');
            a.href = URL.createObjectURL(blob);
            a.download = filename;
            document.body.appendChild(a);
            a.click();
            setTimeout(() => { URL.revokeObjectURL(a.href); a.remove(); }, 0);
        }

        async function captureCanvasFromTable() {
            const node = document.getElementById("ttCapture") || document.getElementById("ttTable") || document.getElementById("gridWrap");
            // use a slightly higher scale for crispness
            const canvas = await html2canvas(node, { scale: 2, backgroundColor: "#ffffff" });
            return canvas;
        }

        async function captureAsPng() {
            const canvas = await captureCanvasFromTable();
            const dataUrl = canvas.toDataURL("image/png");
            const blob = dataURLToBlob(dataUrl);
            const safeName = (tutorName || tutorEmail || "tutor").replace(/\s+/g, "_");
            return { blob, filename: `${safeName}_timetable.png` };
        }

        async function captureAsPdf() {
            const canvas = await captureCanvasFromTable();
            const { jsPDF } = window.jspdf;
            const pdf = new jsPDF({ orientation: "l", unit: "pt", format: "a4" });
            const pageW = pdf.internal.pageSize.getWidth();
            const pageH = pdf.internal.pageSize.getHeight();
            const imgW = pageW - 40; // margins
            const imgH = canvas.height * (imgW / canvas.width);

            let y = 20;
            pdf.addImage(canvas, "PNG", 20, y, imgW, imgH, "", "FAST");

            // If content overflows, split across pages
            let remaining = imgH - (pageH - 40);
            while (remaining > 0) {
                pdf.addPage();
                y = 20 - (imgH - remaining);
                pdf.addImage(canvas, "PNG", 20, y, imgW, imgH, "", "FAST");
                remaining -= (pageH - 40);
            }

            const blob = pdf.output("blob");
            const safeName = (tutorName || tutorEmail || "tutor").replace(/\s+/g, "_");
            return { blob, filename: `${safeName}_timetable.pdf` };
        }

        function buildXlsx() {
            // Flatten rows to a tidy table for Excel
            const data = [
                ["Tutor", tutorName || "", "Email", tutorEmail || ""],
                [],
                ["Day", "Start", "End", "Activity", "Unit Name", "Location", "Weeks", "Campus"]
            ];

            (_mineRows || []).forEach(r => {
                data.push([
                    r.day_of_week || "",
                    r.start_time || "",
                    r.end_time || "",
                    (r.activity_code || "").toUpperCase(),
                    r.unit_name || "",
                    r.location || "",
                    r.weeks || "",
                    r.campus || ""
                ]);
            });

            const ws = XLSX.utils.aoa_to_sheet(data);
            const wb = XLSX.utils.book_new();
            XLSX.utils.book_append_sheet(wb, ws, "Timetable");

            const wbout = XLSX.write(wb, { bookType: "xlsx", type: "array" });
            const blob = new Blob([wbout], { type: "application/vnd.openxmlformats-officedocument.spreadsheetml.sheet" });
            const safeName = (tutorName || tutorEmail || "tutor").replace(/\s+/g, "_");
            return { blob, filename: `${safeName}_timetable.xlsx` };
        }

        function dataURLToBlob(dataUrl) {
            const arr = dataUrl.split(','), mime = arr[0].match(/:(.*?);/)[1];
            const bstr = atob(arr[1]); let n = bstr.length; const u8arr = new Uint8Array(n);
            while (n--) u8arr[n] = bstr.charCodeAt(n);
            return new Blob([u8arr], { type: mime });
        }

        // ---------- Share via email ----------
        async function shareViaEmail({ blob, filename, mime }) {
            const to = tutorEmail || "";
            const subject = `Timetable - ${tutorName || tutorEmail || 'Tutor'}`;
            const body = `Hi,\n\nPlease find attached the timetable.\n\nRegards,\nTutor Allocation System`;

            // Prefer backend (so we can really attach); fallback to alt path, then mailto
            const form = new FormData();
            form.append("to", to);
            form.append("subject", subject);
            form.append("body", body);
            // Use Blob + filename (more compatible than new File(...))
            form.append("attachment", blob, filename);

            const opts = { method: "POST", headers: authHeaders(), body: form, credentials: "include" };

            try {
                // Primary app-scoped endpoint
                let res = await fetch(`${API_BASE}/timetable/utils/send-email/`, opts);
                if (!res.ok) {
                    // Try top-level utility route as a backup
                    res = await fetch(`${API_BASE}/utils/send-email/`, opts);
                }
                if (!res.ok) throw new Error("Failed to send via API.");
                alert("Email sent.");
                return;
            } catch (e) {
                console.warn("Email API failed, falling back to mailto:", e);
            }

            // Fallback (no attachments possible in mailto)
            const mailto = `mailto:${encodeURIComponent(to)}?subject=${encodeURIComponent(subject)}&body=${encodeURIComponent(body)}`;
            window.location.href = mailto;
        }
    </script>

    <script src="https://cdn.jsdelivr.net/npm/bootstrap@5.3.3/dist/js/bootstrap.bundle.min.js"></script>
</body>

</html>